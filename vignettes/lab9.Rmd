---
title: "Lab 9"
author: "Patrick Ha"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
---

# Task 1 

```{r}
getwd()
```


# Task 2

```{r, echo = FALSE}
myboot2<-function(iter=10000,x,fun="mean",alpha=0.05,cx=1.5,...){  #Notice where the ... is repeated in the code
n=length(x)   #sample size

y=sample(x,n*iter,replace=TRUE)
rs.mat=matrix(y,nr=n,nc=iter,byrow=TRUE)
xstat=apply(rs.mat,2,fun) # xstat is a vector and will have iter values in it 
ci=quantile(xstat,c(alpha/2,1-alpha/2))# Nice way to form a confidence interval
# A histogram follows
# The object para will contain the parameters used to make the histogram
para=hist(xstat,freq=FALSE,las=1,
main=paste("Histogram of Bootstrap sample statistics","\n","alpha=",alpha," iter=",iter,sep=""),
...)

#mat will be a matrix that contains the data, this is done so that I can use apply()
mat=matrix(x,nr=length(x),nc=1,byrow=TRUE)

#pte is the point estimate
#This uses whatever fun is
pte=apply(mat,2,fun)
abline(v=pte,lwd=3,col="Black")# Vertical line
segments(ci[1],0,ci[2],0,lwd=4)      #Make the segment for the ci
text(ci[1],0,paste("(",round(ci[1],2),sep=""),col="Red",cex=cx)
text(ci[2],0,paste(round(ci[2],2),")",sep=""),col="Red",cex=cx)

# plot the point estimate 1/2 way up the density
text(pte,max(para$density)/2,round(pte,2),cex=cx)

invisible(list(ci=ci,fun=fun,x=x))# Some output to use if necessary
}
```

Line A

```{r, eval = FALSE}
y=sample(x,n*iter, replace = TRUE) 
```

Create a random sample fo elements selecting from x, the popultaion, using replacement. This line creaets a sample of the sample size n times the input number of iterations. 

Line B
```{r, eval = FALSE}
ci=quantile(xstat,c(alpha/2))
```

Generate quantiles of alpha/2 and 1-aplha/2 of the calulated statistic per iteration. 
 
**More on sample**

Selecting each datum with equal probability allows us to create an unbiased random sample, generating presumably unqiue samples with each iteration. 

**Unique samples with replacement**

```{r}
set.seed(35) # This will give everyone the same sample
sam=round(rnorm(20,mean=10,sd=4),2)
unique(sample(sam,20,replace=TRUE)) # repeat this line 5x

unique(sample(sam,20,replace=TRUE))

unique(sample(sam,20,replace=TRUE))

unique(sample(sam,20,replace=TRUE))

unique(sample(sam,20,replace=TRUE))
```

These all return a smaller smaple size becuase it removes duplicate elements; many elemnts reappear within samples because sampling with replacement is used. Generates the same samples every time the code is run. 

**Unique  sampels without replacement**

```{r}
unique(sample(sam,20,replace=FALSE) )
unique(sample(sam,20,replace=FALSE) )
unique(sample(sam,20,replace=FALSE) )
unique(sample(sam,20,replace=FALSE) )
unique(sample(sam,20,replace=FALSE) )
```

This returns a full sample size because each element is unique and will not be placed back in the population before resampling. Generates different samples every time the code is run. 

**Without unique; sample size > population** 

```{r, error = TRUE}
sample(sam, 21, replace = FALSE) 
```

Return an error because there are no elements left in the population since each element is taken out and not replaced when sampled. 

# Task 3

**Using myboot() make 95% bootstrap intervals for the population mean and record the plots when the folloowigns maples are used: **

**set.seed(39); sam=rnorm(25,mean=25,sd=10)**

```{r}
set.seed(39); sam=rnorm(25,mean=25,sd=10)
myboot2(10000,x=sam,fun="mean",alpha=0.05,xlab="mean",col="Purple",cx=1.5) # mac quartz()
```

The sample mean, 23.88, is lower than the population mean, 25 by 1.12. The population mean is contained in the interval.

**set.seed(30); sam = rchisq(20,df=3)**

```{r}
set.seed(30); sam=rchisq(20,df=3)
myboot2(10000,x=sam,fun="mean",alpha=0.05,xlab="mean",col="Purple",cx=1.5) # mac quartz()
```

The sample mean, 2.94 is slightly lower than the population mean, 3, by .06. The population mean is contained in the interval.

**set.seed(40); sam=rgamma(30,shape=2,scale=3)**

```{r}
set.seed(40); sam=rgamma(30,shape=2,scale=3)
myboot2(10000,x=sam,fun="mean",alpha=0.05,xlab="mean",col="Purple",cx=1.5) # mac quartz()
```

The sample mean, 6.5 is slightly greater tahn the population mena, 6, by .5. The population mean is contained in the interval.

**set.seed(10); sam=rbeta(20,shape1=3,shape2=4)**

```{r}
set.seed(10); sam=rbeta(20,shape1=3,shape2=4)
myboot2(10000,x=sam,fun="mean",alpha=0.05,xlab="mean",col="Purple",cx=1.5) # mac quartz()
```

The sample mean, 0.41 is very close to the population mean, 0.4286 by 0.0186. The population mean is contained in the interval. 

**Using myboot() make 80% (alpha=0.20) bootstrap intervals (iter=10000) for the population variance ùúé2 and record the plots when the following samples are used**

**set.seed(39); sam=rnorm(25,mean=25,sd=10)**

```{r}
set.seed(39); sam=rnorm(25,mean=25,sd=10)
myboot2(10000,x=sam,fun="var",alpha=0.20,xlab="variance",col="blue",cx=1.5) # mac quartz()
```


**set.seed(30); sam=rchisq(20,df=3)**

```{r}
set.seed(30); sam=rchisq(20,df=3)
myboot2(10000,x=sam,fun="var",alpha=0.20,xlab="variance",col="blue",cx=1.5) # mac quartz()

```

**set.seed(40); sam=rgamma(30,shape=2,scale=3)**

```{r}
set.seed(40); sam=rgamma(30,shape=2,scale=3)
myboot2(10000,x=sam,fun="var",alpha=0.20,xlab="variance",col="blue",cx=1.5) # mac quartz()
```

**set.seed(10); sam=rbeta(20,shape1=3,shape2=4)**
```{r}
set.seed(10); sam=rbeta(20,shape1=3,shape2=4)
myboot2(10000,x=sam,fun="var",alpha=0.20,xlab="variance",col="blue",cx=1.5) # mac quartz()
```


# Task 4 
```{r}
myboot2.1<-function(iter=10000,x,fun="mean",alpha=0.05,cx=1.5,...){  #Notice where the ... is repeated in the code
n=length(x)   #sample size

y=sample(x,n*iter,replace=TRUE)
rs.mat=matrix(y,nr=n,nc=iter,byrow=TRUE)
xstat=apply(rs.mat,2,fun) # xstat is a vector and will have iter values in it 
ci=quantile(xstat,c(alpha/2,1-alpha/2))# Nice way to form a confidence interval
# A histogram follows
# The object para will contain the parameters used to make the histogram
para=hist(xstat,freq=FALSE,las=1,
main=paste("Histogram of Bootstrap sample statistics","\n","alpha=",alpha," iter=",iter,sep=""),
...)

#mat will be a matrix that contains the data, this is done so that I can use apply()
mat=matrix(x,nr=length(x),nc=1,byrow=TRUE)

#pte is the point estimate
#This uses whatever fun is
pte=apply(mat,2,fun)
abline(v=pte,lwd=3,col="Black")# Vertical line
segments(ci[1],0,ci[2],0,lwd=4)      #Make the segment for the ci
text(ci[1],0,paste("(",round(ci[1],2),sep=""),col="Red",cex=cx)
text(ci[2],0,paste(round(ci[2],2),")",sep=""),col="Red",cex=cx)

# plot the point estimate 1/2 way up the density
text(pte,max(para$density)/2,round(pte,2),cex=cx)

list(ci=ci,fun=fun,x=x, xstat = xstat)# Some output to use if necessary
}
```

**Use the function**
```{r}
sam=c(1,1,1,2,2,2,2,3,3,3,4,4) 
barplot(myboot2.1(x=sam,fun= "median")$xstat, xlab = "xstat")
```

The bootstrap interval is (1.5, 3)

**Barplot**
```{r}
barplot
```

```{r, echo = FALSE}
myboot2.1<-function(iter=10000,x,fun="mean",alpha=0.05,cx=1.5,...){  #Notice where the ... is repeated in the code
n=length(x)   #sample size

y=sample(x,n*iter,replace=TRUE)
rs.mat=matrix(y,nr=n,nc=iter,byrow=TRUE)
xstat=apply(rs.mat,2,fun) # xstat is a vector and will have iter values in it 
ci=quantile(xstat,c(alpha/2,1-alpha/2))# Nice way to form a confidence interval
# A histogram follows
# The object para will contain the parameters used to make the histogram
para=hist(xstat,freq=FALSE,las=1,
main=paste("Histogram of Bootstrap sample statistics","\n","alpha=",alpha," iter=",iter,sep=""),
...)

#mat will be a matrix that contains the data, this is done so that I can use apply()
mat=matrix(x,nr=length(x),nc=1,byrow=TRUE)

#pte is the point estimate
#This uses whatever fun is
pte=apply(mat,2,fun)
abline(v=pte,lwd=3,col="Black")# Vertical line
segments(ci[1],0,ci[2],0,lwd=4)      #Make the segment for the ci
text(ci[1],0,paste("(",round(ci[1],2),sep=""),col="Red",cex=cx)
text(ci[2],0,paste(round(ci[2],2),")",sep=""),col="Red",cex=cx)

# plot the point estimate 1/2 way up the density
text(pte,max(para$density)/2,round(pte,2),cex=cx)

list(ci=ci,fun=fun,x=x, xstat = round(pte,4))# Some output to use if necessary
}
```

# Task 5 

*### Create the mean/median function
```{r}
mean.median = function(x) {mean(x)/median(x)}
```

## 95% Intervals

**set.seed(39); sam=rnorm(25,mean=25,sd=10)**
```{r}
set.seed(39); sam=rnorm(25,mean=25,sd=10)
myboot2.1(10000,x=sam,fun= mean.median,alpha=0.05,xlab="mean / median",col="Lavender",cx=1.5) # mac quartz()
```

**set.seed(30); sam=rchisq(20,df=3)**
```{r}
set.seed(30); sam=rchisq(20,df=3)
myboot2.1(10000,x=sam,fun= mean.median,alpha=0.05,xlab="mean / median",col="Lavender",cx=1.5) # mac quartz()
```


**set.seed(40); sam=rgamma(30,shape=2,scale=3)**
```{r}
set.seed(40); sam=rgamma(30,shape=2,scale=3)
myboot2.1(10000,x=sam,fun= mean.median,alpha=0.05,xlab="mean / median",col="Lavender",cx=1.5) # mac quartz()
```


## 70% Intervals

**set.seed(39); sam=rnorm(25,mean=25,sd=10)**
```{r}
set.seed(39); sam=rnorm(25,mean=25,sd=10)
myboot2.1(10000,x=sam,fun= mean.median,alpha=0.30,xlab="mean / median",col="Light Blue",cx=1.5) # mac quartz()
```

**set.seed(30); sam=rchisq(20,df=3)**
```{r}
set.seed(30); sam=rchisq(20,df=3)
myboot2.1(10000,x=sam,fun= mean.median,alpha=0.30,xlab="mean / median",col="Light Blue",cx=1.5) # mac quartz()
```


**set.seed(40); sam=rgamma(30,shape=2,scale=3)**
```{r}
set.seed(40); sam=rgamma(30,shape=2,scale=3)
myboot2.1(10000,x=sam,fun= mean.median,alpha=0.30,xlab="mean / median",col="Light Blue",cx=1.5) # mac quartz()
```


**set.seed(10); sam=rbeta(20,shape1=3,shape2=4)**
```{r}
set.seed(10); sam=rbeta(20,shape1=3,shape2=4)
myboot2.1(10000,x=sam,fun= mean.median,alpha=0.30,xlab="mean / median",col="Light Blue",cx=1.5) # mac quartz()
```

# Task 6

**runif(20,min=0,ma=1)**
```{r}
set.seed(39); runif(20,min=0,max=1)
```

**rweibull(20,shape=1,scale=3)**
```{r}
set.seed(30); rweibull(20,shape=1,scale=3)
```

**rexp(20,rate=2)**
```{r}
set.seed(40); rexp(20,rate=2)
```

**rpois(20,lambda=4)**
```{r}
set.seed(10); rpois(20,lambda=4)
```

**Bootstrap**

**set.seed(39); sam=runif(20,min=0,max=1)**

Mean
```{r}
set.seed(39); sam=runif(20,min=0,max=1)
unifmean = myboot2.1(10000,x=sam,fun= "mean",alpha=0.20,xlab="mean",col="orange",cx=1.5) # mac quartz()
```
Median
```{r}
set.seed(39); sam=runif(20,min=0,max=1)
unifmedian = myboot2.1(10000,x=sam,fun= "median",alpha=0.20,xlab="median",col="yellow",cx=1.5) # mac quartz()
```

**set.seed(30); sam=rweibull(20,shape=1,scale=3)**

Mean
```{r}
set.seed(30); sam=rweibull(20,shape=1,scale=3)
weibullmean = myboot2.1(10000,x=sam,fun= "mean",alpha=0.20,xlab="mean",col="orange",cx=1.5) # mac quartz()
```

Median
```{r}
set.seed(30); sam=rweibull(20,shape=1,scale=3)
weibullmedian = myboot2.1(10000,x=sam,fun= "median",alpha=0.20,xlab="median",col="yellow",cx=1.5) # mac quartz()
```

**set.seed(40); sam=rexp(20,rate=2)**

Mean
```{r}
set.seed(40); sam=rexp(20,rate=2)
expmean = myboot2.1(10000,x=sam,fun= "mean",alpha=0.20,xlab="mean",col="orange",cx=1.5) # mac quartz()
```

Median
```{r}
set.seed(40); sam=rexp(20,rate=2)
expmedian = myboot2.1(10000,x=sam,fun= "median",alpha=0.20,xlab="median",col="yellow",cx=1.5) # mac quartz()
```

**set.seed(10); sam=rpois(20,lambda=4)**

Mean

```{r}
set.seed(10); sam=rpois(20,lambda=4)
poismean = myboot2.1(10000,x=sam,fun= "mean",alpha=0.20,xlab="mean",col="orange",cx=1.5) # mac quartz()
```

Median

```{r}
set.seed(10); sam=rpois(20,lambda=4)
poismedian = myboot2.1(10000,x=sam,fun= "median",alpha=0.20,xlab="median",col="Light Cyan",cx=1.5) # mac quartz()
```

# Task 7 

**set.seed(68); sam=rnorm(20,mean=10,sd=4)**

IQR/sd

```{r}
IQR.sd = function(x) {IQR(x)/sd(x)}
set.seed(68); sam=rnorm(20,mean=10,sd=4)
normIQR = myboot2.1(10000,x=sam,fun= IQR.sd,alpha=0.05,xlab="IQR/sd",col="Plum",cx=1.5) # mac quartz()
```

Variance 

```{r}
set.seed(68); sam=rnorm(20,mean=10,sd=4)
normvar = myboot2.1(10000,x=sam,fun= "var",alpha=0.05,xlab="var",col="Light green",cx=1.5) # mac quartz()
```

**Manually**
```{r}
set.seed(68); sam=rnorm(20,mean=10,sd=4)
alpha = .05
mp = c(-1, 1)
err = qnorm(1-alpha/2,mean=0,sd=1)
mean(sam) + mp*err
```

**Using bootstrap**
```{r}
set.seed(68); sam=rnorm(20,mean=10,sd=4)
myboot2.1(10000,x=sam,fun= "mean",alpha=0.05,xlab="mean",col="Light Pink",cx=1.5) # mac quartz()
```

**Compare**

The manually calculated confidence interval is slightly wider than the bootstrap interval. Its lower bound is 8.50, which is 0.36 lower than the bootstrap interval‚Äôs lower bound. Its upper bound is 12.42, which is 0.54 higher than the bootstrap interval‚Äôs upper bound. The sample mean for the manual interval is 10.45931, which matches the bootstrap sample mean of 10.4593.

# Task 8
```{r}
fire = MATH4753SPRINGHA::fire
obj = MATH4753SPRINGHA::myboot2(x=fire$DAMAGE)
```




